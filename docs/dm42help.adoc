:allow-uri-read:
:stylesheet: https://tech.swissmicros.com/User-Manuals/usermanuals.css
:linkcss:
:toc: left
:toclevels: 5
:lang: en

:version: 0.1

:title-page: Quick Reference Guide
= Quick Reference Guide
SwissMicros GmbH
Copyright 2017-{localyear} v{version} {docdate}


[[Top]]
== DM42 Quick Reference Guide

* Inspired by the HP-42S Quick Reference Guide (c) Copyright 1988 Dex Smith

=== Navigation

* Press [.button]#÷# to move one page backward
* Press [.button]#×# to move one page forward
* Press [.button]#-# to move one line backward
* Press [.button]#+# to move one line forward
* Press [.button]#▲# to select previous link
* Press [.button]#▼# to select next link
* Press [.button]#ENTER# to jump to selected link
* Press [.button]#EXIT# or [.button]#F1# to exit
* Press [.button]#F2# to jump to link:#Home[Contents]
* Press [.button]#F3# to open help file selection dialog

=== Numpad-like navigation keys

* [.button]#2#/[.button]#8# - single line down/up
* [.button]#3#/[.button]#9# - page down/up
* [.button]#4#/[.button]#6# - prev/next link (same as arrows)
* [.button]#5# - follow the link (same as [.button]#ENTER#)
* [.button]#7# - go to the link:#Home[Contents] (same as [.button]#F2#)

=== Symbols used in this guide

* A [.lcd]#123# represents a soft button or anything on the LCD
* A [.button]#STO# represents a physical button

 +

[[Home]]
=== Contents

* link:#Using_Menus[Menus]
* link:#Memory[Storage]
* link:#Data_Types[Data Types]
* link:#Modes[Modes]
* link:#Executing_Functions_Programs[Executing Functions & Programs]
* link:#Programming[Programming]
* link:#Using_a_Variable_Menu[Using a Variable Menu]
* link:#The_Solver[The Solver]
* link:#Numerical_Integration[Numerical Integration]
* link:#Matrix_Operations[Matrix Operations]
* link:#Statistics[Statistics]
* link:#Base_Conversions[Base Conversions]
* link:#DM42_Functions[DM42 Functions]
* link:#HP-41_Functions[HP-41 Functions]
* link:#Using_the_ALPHA_Menu[Using the ALPHA Menu]
* link:#Flags[Flags]
* link:#Virtual_variables[Virtual variables]
* link:#F_Buttons[F-Buttons]
* link:#Screenshot[Screenshot]
* link:#Setup_Menu[Setup Menu]
* link:#About[About]

 +

[[Using_Menus]]
=== Menus

DM42 calculator has far too many functions to assign a key to each one,
so most of them are available in menus rather than directly on keys. +
Each menu displays a row of labels at the bottom of the screen, one
above each key in the top row of the keyboard. +
A function within the menu is activated by pressing the key directly
below it. If there are more than six functions in the menu then the
[.lcd]#▼▲# annunciator is displayed and the [.button]#▼# and
[.button]#▲# keys allow you to scroll through the menu's pages. There
are two kinds of menu:

* link:#Application_Menus[Application Menu]
* link:#Function_Menus[Function Menu]

 +

[[Application_Menus]]
==== Application Menu

There are five applications built into the DM42:

* [.button]#BASE# link:#Base_Conversions[Base Conversions]
* [.button]#MATRIX# link:#Matrix_Operations[Matrix Operations]
* [.button]#SOLVER# link:#The_Solver[The Solver]
* [.button]#STAT# link:#Statistics[Statistics]
* [.button]#∫f(x)# link:#Numerical_Integration[Numerical Integration]

 +
When you enter an application and its menu opens, any other menus are
closed automatically. However, you can still open a function menu from
within the application and when you've finished with it, it will close
and reveal the application menu again. +
 +

[[Function_Menus]]
==== Function Menu

* [.button]#CATALOG# All link:#DM42_Functions[DM42 Functions]
* [.button]#CLEAR# Functions for clearing programs and variables
* [.button]#CONVERT# Angle, time, and coordinate conversion functions
* [.button]#CUSTOM# Displays custom menu
* [.button]#DISP# link:#Display_Formats[Display Formats]
* [.button]#FLAGS# link:#Flags[Flags]
* [.button]#MODES# link:#Angles_Coordinates[Angles and Coordinates]
* [.button]#PGM.FCN# Functions useful in programs
* [.button]#PRINT# Enable IR link:#Printing[Printing]
* [.button]#PROB# Combinatorics and probability functions

 +
Unlike application menus, a Function menu closes as soon as you have
used one of the functions that it contains, with the exception of the
[.button]#CUSTOM# menu, which remains open. Should you need to use more
than one function from a Function menu, you can instruct the DM42 to
keep the menu open by opening it twice in succession. +
 +

[[Memory]]
=== Storage

* link:#The_Stack[The Stack]
* link:#Storage_Registers[Storage Registers]
* link:#Variables[Variables]
* link:#Alpha_Register[The Alpha Register]
* link:#Flags[Flags (00-99)]
* link:#Available_Memory[Available Memory]

 +

[[The_Stack]]
==== The Stack

The stack is the scratchpad that you use for performing calculations. It
stores and shows you intermediate results as you work through a
problem. +
The four registers that make up the stack are known as X,Y,Z,T.
Auxiliary register LASTx holds contents of X register used in most
recent numeric function. Each of these registers can contain data of any
link:#Data_Types[type]. +
 +

[[Storage_Registers]]
==== Storage Registers

Because of the ephemeral nature of the stack, data in its registers is
likely to be lost when a new calculation is started. +
More permanent storage can be achieved in the storage registers, of
which there are 25 initially, numbered 00 to 24. This number can be
altered with the SIZE function in the [.button]#MODES# menu. +
[.button]#STO# _nn_ STOres the contents of the X register into the
storage register with the given number. +
[.button]#RCL# _nn_ ReCaLls the data from storage register _nn_ into the
stack. +
If SIZE has been used to define more than 100 storage registers then
registers numbered 100 and onwards can only be accessed using
link:#Specifying_Function_Parameters[indirect addressing]. +
The [.button]##STAT##istics application uses some of the storage
registers for its internal housekeeping: +

* R11 Σ x
* R12 Σ x^2^
* R13 Σ y
* R14 Σ y^2^
* R15 Σ xy
* R16 n

If [.lcd]#ALLΣ# mode is being used (as opposed to [.lcd]#LINΣ# mode)
then the following additional storage registers are used:

* R17 Σ ln x
* R18 Σ (ln x)^2^
* R19 Σ ln y
* R20 Σ (ln y)^2^
* R21 Σ ln x ln y
* R22 Σ x ln y
* R23 Σ y ln x

The storage registers can be all real numbers or all complex numbers.
See link:#Variables[Variables] for how to switch between the two. +
 +

[[Variables]]
==== Variables

Rather than referring to stored data by a simple number (the number of
the storage register containing it), it is possible to create named
variables. Variables allow you to associate a meaningful name with the
data. Also, named variables can contain any link:#Data_Types[type of
data], not just real or complex numbers. +
E.g. suppose you have just calculated the volume of a shape. Store the
value currently in the X register representing this volume in a variable
named _VOL_: +
[.button]#STO# [.button]#ENTER# [.lcd]#VOL# [.button]#ENTER# +
Variables can have names up to seven characters long. +
There is one system-reserved variable, [.lcd]#REGS#. [.lcd]#REGS# is a
matrix containing the storage registers. [.lcd]#REGS# can be a real
matrix, in which case all of the storage registers, i.e. the elements of
[.lcd]#REGS#, are real numbers, or it can be a complex matrix, in which
case all of the storage registers are complex numbers. +
To convert [.lcd]#REGS# (or any other real matrix) to a complex
matrix: +
0 [.button]#ENTER# [.button]#COMPLEX# [.button]#STO# [.button]#+#
[.lcd]#REGS# +
To convert [.lcd]#REGS# from a complex matrix back into a real matrix: +
[.button]#RCL# [.lcd]#REGS# [.button]#COMPLEX# [.button]#x<>y#
[.button]#STO# [.lcd]#REGS# +
 +

[[Alpha_Register]]
==== The Alpha Register

The alpha Register can store up to 44 characters of text, which equate
to two lines of text on the original HP-42S. +
 +

[[Available_Memory]]
==== Available Memory

The DM42 has about 70KB of system memory that your programs and
variables can use. The link:#Storage_Registers[storage register] matrix
[.lcd]#REGS# uses some of this space. +
To find out how much memory your DM42 has available, open the
[.button]#CATALOG# menu and then press and hold [.lcd]#MEM#. +
If you need more memory then use the [.lcd]#CLP# (CLear Program) and
[.lcd]#CLV# (CLear Variable) functions from the [.button]#CLEAR# menu to
remove unneccesary programs and variables and thus free up additional
memory. +
DO NOT DELETE THE [.lcd]#REGS# VARIABLE! Remember, it holds your storage
registers! If necessary you can reduce its size with the [.lcd]#SIZE#
command from the [.button]#MODES# menu. +
 +

[[Data_Types]]
=== Data Types

* link:#Real_Numbers[Real Numbers]
* link:#Complex_Numbers[Complex Numbers]
* link:#Alpha_Strings[Alpha Strings]
* link:#Matrices[Matrices]

 +

[[Real_Numbers]]
==== Real Numbers

Real numbers cover integer and decimal numbers, positive or negative.
The range of numbers that the DM42 can handle is approximately 10^-6143^
to 10^6144^ with a precision of 34 digits. +
 +

[[Complex_Numbers]]
==== Complex Numbers

A complex number consists of two real numbers associated to form its
real part and its imaginary part (_rectangular_ coordinate mode). +
Complex numbers are always stored internally in rectangular form but can
be displayed directly: +
[.lcd]#0.2343 i1.4456# +
or in _polar_ coordinate mode with a magnitude and an angle: +
[.lcd]#1.4645 ∡80.7937# +
Both of the examples here represent the same complex number. +
To enter a complex number in rectangular mode: +
_real part_ [.button]#ENTER# _imaginary part_ [.button]#COMPLEX# +
To enter a complex number in polar mode: +
_Magnitude_ [.button]#ENTER# _angle_ [.button]#COMPLEX# +
The [.button]#COMPLEX# function either combines real numbers (or
matrices) in the X and Y stack registers to form a complex number (or
matrix) in X, or it performs the opposite operation by splitting the
complex number (or matrix) in X into two real numbers (or matrices) in X
and Y. +
The role of the real number (or matrix) taken from X when combining X
and Y or left in X when splitting the complex number (or matrix) in X
depends on the display mode, rectangular or polar, in force when
[.button]#COMPLEX# is executed. If _rectangular_ then X is/was the
imaginary part. If _polar_ then X is/was the angle. +
Complex numbers are displayed in polar mode normalised such that the
magnitude is always positive and the absolute value of the angle does
not exceed 180 degrees. +
 +

[[Alpha_Strings]]
==== Alpha Strings

The alpha register contains strings of text up to 44 characters (2 lines
on the HP-42S) in length. +
Real variables and elements of real matrices (including [.lcd]#REGS# )
can also contain strings of up to 6 characters in length. Basically, you
can store snippets of text anywhere you can store real numbers. However,
you cannot store two such snippets in a complex variable. +
 +

[[Matrices]]
==== Matrices

Matrices can be one-dimensional or two-dimensional. A matrix can have
any number of rows and columns as long as there is enough memory in the
DM42 to store all of its individual elements. +
See link:#Matrix_Operations[Matrix Operations] for more details. +
 +

[[Modes]]
=== Modes

* link:#Angles_Coordinates[Angles and Coordinates]
* link:#Other_Modes[Other Modes]
* link:#Display_Formats[Display Formats]
* link:#Printing[Printing]

 +

[[Angles_Coordinates]]
==== Angles and Coordinates

Press [.button]#MODES# +
The angle specifiers [.lcd]#DEG#, [.lcd]#RAD# and [.lcd]#GRAD# tell the
DM42 to use degrees, radians, and gradians respectively when displaying
and interpreting angles. +
[.lcd]#RECT# and [.lcd]#POLAR# tell the DM42 to display and interpret
complex numbers in rectangular and polar mode, respectively. +
 +

[[Other_Modes]]
==== Other Modes

Press [.button]#MODES# [.button]#▼# +
[.lcd]#SIZE# resizes the [.lcd]#REGS# matrix variable, thus defining the
number of link:#Storage_Registers[storage registers] you can use. +
[.lcd]#QUIET# switches off the internal buzzer and keeps the DM42 nice
and.... quiet! +
[.lcd]#CPXRES# allows the DM42 to return complex results when working on
real numbers (e.g. square root of a negative number) while
[.lcd]#REALRES# ensures that only real numbers are returned. In this
case, operations that would otherwise return a complex result trigger an
[.lcd]#Invalid Data# error. Operations given a complex number as an
argument will return a complex number regardless of the
[.lcd]#CPXRES#/[.lcd]#REALRES# setting. +
[.lcd]#KEYASN# means that variables and programs assigned to the
[.button]#CUSTOM# menu with the [.button]#ASSIGN# command will be shown
in the [.button]#CUSTOM# menu. If [.lcd]#LCLBL# is selected then local
alpha labels populate the [.button]#CUSTOM# menu. +
 +

[[Display_Formats]]
==== Display Formats

Press [.button]#DISP# +
[.lcd]#FIX#, [.lcd]#SCI# and [.lcd]#ENG# instruct the DM42 to display
real numbers in fixed decimal, scientific and engineering notation,
respectively, with a set number of decimals. +
When [.lcd]#ALL# is selected, numbers are displayed with up to 12 digits
precision, which was the native precision of the HP-42S. +
Depending on where in the world you are, you will be used to using a dot
as the decimal separator and a comma for grouping digits three by three
before the decimal (e.g. [.lcd]#1,234.56# ) or, as in most of Europe, a
comma as the decimal separator and a dot for grouping digits before the
decimal (e.g. [.lcd]#1.234,56# ). [.lcd]#RDX.# selects the dot as the
decimal separator and [.lcd]#RDX,# selects the comma. +
 +

[[Printing]]
==== Printing

Press [.button]#PRINT# [.button]#▲# +
[.lcd]#PRON# and [.lcd]#PROFF# enable and disable printing by setting or
clearing respectively link:#Flags[flags] 21 and 55. +
[.lcd]#MAN# leads to items being printed manually. [.lcd]#NORM# leads to
input and calculation results alone being printed automatically while
[.lcd]#TRACE# sends a trace of all operations to the printer. +
Additional modes are described under "Matrix Operations" and
"Statistics." +
 +

[[Executing_Functions_Programs]]
=== Executing Functions & Programs

* link:#Short_Cuts[Quick access to programs and functions]
* link:#Specifying_Function_Parameters[Addressing modes]

 +
Any function or program can be executed by pressing [.button]#XEQ# and
entering its name. If there is more than one program with the same name
then when you attempt to [.button]#XEQ# that program, the one closest to
the permanent [.lcd]#.END.# marker will be executed. +
Only the current program will be searched if the name that you give is
that of a local label. +
 +

[[Short_Cuts]]
==== Quick access to programs and functions

There are four ways to get at your programs and at the DM42's functions
quickly:

* You can [.button]#ASSIGN# up to 18 names of programs or variables to
the [.button]#CUSTOM# menu. Pressing an item in the [.button]#CUSTOM#
menu is the same as executing it ([.button]#XEQ# ) if it's a program or
built in function or, if it is a variable, recalling it ([.button]#RCL#
).
* When you press the [.button]#XEQ# button, the program catalog is
automatially presented to you. Simply scroll through the catalog with
the [.button]#▲# and [.button]#▼# keys if needed and select the program
to run.
* The Run/Stop Key [.button]#R/S# starts running the current program at
the current line or stops a running program once the instruction that it
is working on has completed.
* All of the built in functions of the DM42 are available in the
Function Catalog that can be opened by pressing [.button]#CATALOG#
[.lcd]#FCN#

 +

[[Specifying_Function_Parameters]]
==== Addressing modes

Some functions require a parameter that tells them on what specific item
to operate. These functions accept one or more of the following
addressing modes:

* *Numeric*: these functions include [.button]#RCL#, [.lcd]#SF#,
[.button]#GTO#, and others. They prompt you to enter a numerical value
by displaying an underscore for each digit that they are expecting. For
example, if you press [.button]#SIZE#, the DM42 displays +
[.lcd]#SIZE ____# +
prompting you to input four digits. You can always input fewer digits
and terminate the input with [.button]#ENTER# and the DM42 will assume
that the missing digits are zeroes on the left.
* *Alpha*: some functions that accept numeric addressing also accept
alpha addressing. An example of one such function is [.button]#RCL#,
which allows you to specify the number of a
link:#Storage_Registers[storage register] to recall or the (alpha) name
of a variable. In many cases, the DM42 will show you a menu of alpha
names that are valid for the instruction that you are typing but if not,
you can always use the [.button]#ALPHA# menu to type it in yourself.
* *Stack*: because the stack registers can hold anything that a storage
register can, they can also be used in place of a storage register. For
example, to recall the contents of the T register into X (trick to roll
the stack upwards instead of downwards), do the following: +
[.button]#RCL# [.button]#.# [.lcd]#ST T#
* *Indirect Addressing*: this is a technique that does not give the DM42
the parameter that it needs. Instead, it tells the DM42 _where_ to find
that parameter. For example, to execute the program whose name is stored
in storage register 24, you would: [.button]#XEQ# [.button]#.# 24 +
Stack registers can also be used with indirect addressing. For example,
suppose that the name of the program that you want to execute is not in
R24 but in the X register of the stack. In this case you would: +
[.button]#XEQ# [.button]#.# [.button]#.# [.lcd]#ST X#

 +

[[Programming]]
=== Programming

* link:#Program_Entry[Program-Entry]
* link:#Labels[Labels]
* link:#Do_lf_True_Rule[The Do-lf-True Rule]
* link:#Looping[Looping]

 +

[[Program_Entry]]
==== Program-Entry

* [.button]#PRGM# enters or exits Program-entry mode
* [.button]#GTO# [.button]#.# [.button]#.# moves to a new program space
* [.button]#GTO# [.button]#.# nnnn moves to line number nnnn
* [.button]#←# deletes the current program line
* [.button]#SST# moves to the next program line*
* [.button]#BST# moves to the previous pgm line*

 +
* Use [.button]#▲# or [.button]#▼# if no menu is displayed. +
 +

[[Labels]]
==== Labels

A program label is simply a marker used to identify a program or a
routine within a program. +
*Global labels* can be accessed from anywhere in memory (and therefore
should be unique). Global labels are distinguished from local labels by
quotation marks (such as [.lcd]#LBL "SAMPLE"# ). +
*Local labels* can be accessed only within the current program (and
should be unique within the current program). There are two types of
local labels: +

* Numeric (LBL 00 - LBL 99)
* Alpha ([.lcd]#LBL A# - [.lcd]#LBL J# and [.lcd]#LBL a# - [.lcd]#LBL e#
)

 +

[[Do_lf_True_Rule]]
==== The Do-lf-True Rule

The do-if-true rule determines how program lines are executed when a
conditional function is encountered. If the condition is "true," the
line immediately following the conditional is _executed_. If the
condition is "false," the line following the conditional is _skipped._ +
 +

[[Looping]]
==== Looping

The ISG and DSE functions control looping. Each accesses a variable or
register containing a control number in the form _ccccccc.fffii_; where
_ccccccc_ is the current counter value, and _fff_ is the ﬁnal counter
value, and _ii_ is the increment size (default is 1). Both ISG and DSE
follow a variation of the do-if-true rule: if the count is not complete,
the line following the instruction is executed (usually a branch to the
top of the loop). +
For example, this program segment counts from 1 to 52 by threes
(executing the loop 18 times) and then beeps. +
[.lcd]#17 1.05203# +
[.lcd]#18 STO "COUNT"# +
[.lcd]#19 LBL 01# +
… +
[.lcd]#23 ISG "COUNT"# +
[.lcd]#24 GTO 01# +
[.lcd]#25 BEEP# +
 +

[[Using_a_Variable_Menu]]
=== Using a Variable Menu

A variable menu may be displayed by the Solver or Integration
applications, or by the VARMENU function within a program. Each label in
the menu represents a variable. While the menu is displayed, you can: +

* *Store a value into a variable:* +
Key in the value and then press the menu key.
* *Recall the contents of a variable:* +
Press [.button]#RCL# and then the menu key.
* *View the contents of a variable without recalling it:* +
Press (shift) and then hold the menu key down.
* *Select a variable:* +
Press the menu key without keying in a number first. This action places
the variable name in the alpha register and continues execution. +
(For the Solver, this is how you select the unknown variable. For
Integration, this is how you select the variable of integration.)

You can select and use any function menu without exiting from the
variable menu. +
 +

[[The_Solver]]
=== The Solver

The Solver is a root finder that allows you to solve for an unknown
variable in an expression, given values for all the other variables.
Expressions are written as programs. There are three parts to a Solver
program: +

* The program must begin with *a global label.*
* Immediately following the global label, *menu variables* are declared
with MVAR instructions.
* Finally, the body of the program should evaluate the expression.
Recall the variables as they are needed and calculate _f(x)_ (where
_f(x)_ = 0 for your expression of one or many variables).

 +
After entering the program, these are the steps for using the Solver: +

* Press [.button]#SOLVER#
* Select a Solver pgm from the menu.
* Use the variable menu to store a value into each of the known
variables. Optional: store one or two guesses into the unknown variable
to direct the Solver to a solution.
* Solve for the unknown variable by pressing the corresponding menu key.

 +
*A Simple Example:* For the expression _A + B = C_, rewrite the
expression as _A + B - C_ = 0. The Solver program looks like this: +
 +
[.lcd]#01 LBL "SIMPLE"# +
[.lcd]#02 MVAR "A"# +
[.lcd]#03 MVAR "B"# +
[.lcd]#04 MVAR "C"# +
[.lcd]#05 RCL "A"# +
[.lcd]#06 RCL+ "B"# +
[.lcd]#07 RCL- "C"# +
[.lcd]#08 END# +
 +
Hint: create the variables before entering the program. After entering
the program, you can use it to solve for any variable, given a value for
each of the others. For example, find _A_ when _B_ = 12 and _C_ =
log(_B_ ). +
 +
Select the program: [.button]#SOLVER# [.lcd]#SIMPL# +
Store _B_: 12 [.lcd]#B# +
Store _C_: [.button]#LOG# [.lcd]#C# +
Solve for _A_: [.lcd]#A# +
 +

[[Numerical_Integration]]
=== Numerical Integration

The Numeric Integration application allows you to calculate an
approximation of a definite integral. The integrand, _f(x)_, is written
as a program similar to a Solver program (see link:#The_Solver[The
Solver] ). That is, the program must use a global label, declare the
menu variables, and evaluate _f(x)_. +
 +
After entering the integrand program, here are the steps for using the
Integration application: +

. Press [.button]#∫f(x)#
. Select an integrand program from the menu.
. Use the variable menu to store a value into each of the variables that
should remain constant.
. Select the variable of integration by pressing the corresponding menu
key.
. Store the lower limit (_LLIM_ ), the upper limit (_ULIM_ ), and the
accuracy factor (_ACC_ ).
. Press [.lcd]#∫# to calculate the integral. The approximation for the
integral is returned to the X-register and the uncertainty of
computation is returned to the Y-register.

 +

[[Matrix_Operations]]
=== Matrix Operations

To create a new _m × n_ matrix, enter the dimensions: +
_m_ [.button]#ENTER# _n_ (for m rows and n columns) and then press: +
[.button]#MATRIX# [.lcd]#NEW# for a matrix in the X-register. +
Or [.button]#MATRIX# [.button]#▼# [.lcd]#DIM# [.button]#ENTER# _name_
[.button]#ENTER# for a matrix in a variable. If the matrix already
exists, the DIM function redimensions it. +
 +
*Edit the matrix in the X-register:* +
[.button]#MATRIX# [.lcd]#EDIT# +
 +
*Edit a named matrix:* +
[.button]#MATRIX# [.lcd]#▼# [.lcd]#EDITN# [.button]#name# +
 +
When a matrix is being edited it is said to be indexed. (To index a
named matrix without editing it, use the INDEX function.) Whenever
there’s an indexed matrix, two pointers are used to indicate the row and
column of the current element: _I_ and _J_, respectively. +
 +
*Wrap and Grow Modes.* If the index pointers are positioned to the last
(lower-right) element in a matrix and you move to the right one
position: +

* The pointers wrap around to the first element of the matrix (Wrap
mode).
* Or, the matrix grows by one complete row and the pointers move to the
new row (Grow mode).

Wrap mode is automatically selected whenever you enter or exit the
matrix editor. (The WRAP and GROW functions are in the second row of the
editor menu.) +
 +
*Matrix Arithmetic.* Most arithmetic and other operations work for
matrices just as for individual numbers. Anytime a matrix is used in a
mathematical operation with a complex number, the result is a complex
matrix. Therefore, you can make any matrix complex by adding 0 + __i__0
to it: +
0 [.button]#ENTER# [.button]#COMPLEX# [.button]#+# +
or 0 [.button]#ENTER# [.button]#COMPLEX# [.button]#STOM# [.button]#+#
name +
 +
*To solve a system of simultaneous linear equations represented by the
matrix equation AX = B:* +

. Press [.button]#MATRIX# [.lcd]#SIMQ#.
. Key in the number of unknowns. The calculator automatically creates or
redimensions the matrix variables _MATA, MATB,_ and _MATX._
. Optional: If your equations involve complex numbers, make _MATA_
and/or _MATB_ complex (as shown at the top of this page).
. Press [.lcd]#MATA# , fill the matrix and press [.button]#EXIT#
. Press [.lcd]#MATB# , fill the matrix and press [.button]#EXIT#
. Press [.lcd]#MATX# to calculate the solution matrix. Use the matrix
editor keys to view the results.

 +

[[Statistics]]
=== Statistics

Statistical data is accumulated into 6 or 13 sequential
link:#Storage_Registers[storage registers]. Initially, the first
summation register is R11. Use the ΣREG function to change the location
of the first summation register. ΣREG does not move the data in the
registers. +
 +
*Options to set the summation mode:* +

* [.button]#STAT# [.button]#▼# [.lcd]#ALLΣ# to use all 13 coefficients
* [.button]#STAT# [.button]#▼# [.lcd]#LINΣ# to use only the first six
coefficients (which allows only linear curve fitting)

*Clear the summation registers:* +
[.button]#CLEAR# [.lcd]#CLΣ# +
 +
*Options to accumulate data:* +

* For each _x-y_ data pair: _y-value_ [.button]#ENTER# _x-value_
[.button]#Σ+#
* For each single-point data value: _x-value_ [.button]#Σ+#
* For _x-y_ data pairs stored in a two-column matrix (_x-values_ in
column 1; _y-values_ in column 2): Place the matrix in the X-register
and then press [.button]#Σ+#

 +
*To undo mistakes:* +
Put the incorrect data in the stack (try [.button]#LASTx# ). +
Press [.button]#Σ-# and continue accumulating data. +
 +
*To select a curve model for forecasting:* +
Press [.button]#STAT# [.lcd]#CFIT# [.lcd]#MODL# +
and then one of the following: +

* [.lcd]#LINF# _linear model: y = mx + b_
* [.lcd]#LOGF# _logarithmic model: y = m ln(x) + b_
* [.lcd]#EXPF# _exponential model: ln(y) = mx + ln(b)_
* [.lcd]#PWRF# _power model: ln(y) = m ln(x) + ln(b)_
* [.lcd]#BEST# selects the model that returns the best correlation
coefficient

 +

[[Base_Conversions]]
=== Base Conversions

Real numbers are displayed according to the current base mode
(Hexadecimal, Decimal, Octal, or Binary). You can change the base mode
using the BASE menu or by manually executing HEXM, DECM, OCTM, or BINM.
Decimal mode is automatically selected when you exit from the BASE
menu. +
Press and hold [.button]#SHOW# to display: +

* A hexadecimal, decimal, or octal number in full-precision decimal
form.
* Or, all 36 bits of a binary number.

 +
When the BASE menu is displayed, the following keys are temporarily
redefined with these integer functions: +

[cols=",",]
|===
|[.button]#±# BASE± |36-bit 2’s complement.
|[.button]#÷# BASE÷ |36-bit integer divide.
|[.button]#×# BASE× |36-bit integer multiply.
|[.button]#-# BASE- |36-bit integer subtract.
|[.button]#+# BASE+ |36-bit integer add.
|===

 +
Bits are numbered from right to left beginning with 0. Bit 35 (the most
significant bit) is the sign bit. Negative numbers are represented in
2’s complement form. Nondecimal numbers longer than 36 bits are
displayed as [.lcd]#<Too Big># +
 +

[[DM42_Functions]]
=== DM42 Functions

[cols=",,,",]
|===
|ABS | |Absolute value |
|ACOS | |Arc cosine |
|ACOSH | |Arc hyperbolic cosine |
|ADV | |Advance paper |
|AGRAPH |Alpha graphics | |
|AIP | |Alpha integer part |
|ALENG | |Alpha length |
|ALL | |All display format |
|ALLΣ | |ALLΣ mode (13 sum regs) |
|AND | |Logical AND |
|AOFF | |Alpha off |
|AON | |Alpha on |
|ARCL | |Alpha recall |
|AROT | |Alpha rotate |
|ASHF | |Alpha shift |
|ASIN | |Arc sine |
|ASINH | |Arc hyperbolic sine |
|ASSIGN |Assign CUSTOM menu key | |
|ASTO | |Alpha store |
|ATAN | |Arc tangent |
|ATANH |Arc hyperbolic tangent | |
|ATOX | |Alpha to X |
|AVIEW | |Alpha view |
|BASE+ | |Base add |
|BASE- | |Base subtract |
|BASE× | |Base multiply |
|BASE÷ | |Base divide |
|BASE+/- |Base change sign (2’s compl.) | |
|BEEP | |Beep |
|BEST | |Best ﬁt model |
|BINM | |Binary mode |
|BIT? | |Bit test (x-th bit of y) |
|BST | |Back step |
|CF | | |Clear ﬂag
|CLA | |Clear alpha register |
|CLALL | |Clear all memory |
|CLD | |Clear display |
|CLKEYS |Clear CUSTOM menu keys | |
|CLLCD | |Clear LCD |
|CLMENU |Clear programmable menu | |
|CLP | |Clear program |
|CLRG | |Clear registers |
|CLST | |Clear stack |
|CLV | |Clear variable |
|CLX | |Clear X-register |
|CLΣ | |Clear summation registers |
|COMB | |Combinations |
|COMPLEX |Complex | |
|CORR | |Correlation |
|COS | |Cosine |
|COSH | |Hyperbolic cosine |
|CPXRES |Complex-result enable | |
|CPX? | |Complex test |
|CROSS |Cross product | |
|CUSTOM |CUSTOM menu | |
|DECM | |Decimal mode |
|DEG | |Degrees mode |
|DEL | |Delete program lines |
|DELAY |Printer delay time | |
|DELR | |Delete matrix row |
|DET | |Determinant |
|DIM | |Dimension matrix |
|DIM? | |Dimensions of matrix in X |
|DOT | |Dot product |
|DSE | |Decrement, skip if ≤ zero |
|EDIT | |Edit matrix in X-register |
|EDITN | |Edit named matrix |
|END | |End of a program |
|ENG | |Engineering display format |
|ENTER |Enter | |
|EXITALL |Exit all menus | |
|EXPF | |Curve-fitting model: exp. |
|E↑X | |Natural exponential |
|E↑X-1 | |Nat. exp values near zero |
|FCSTX |Forecast x given y (stat) | |
|FCSTY |Forecast y given x (stat) | |
|FIX | |Fixed dec. display format |
|FRNM | |Frobenius norm of X matrix |
|FP | | |Return fractional part
|GAMMA | |Gamma function |
|GETKEY |Put next key number to X-reg | |
|GETM | |Get matrix |
|GRAD | |Grads angular mode |
|GROW | |Grow mode (matrix edition) |
|GOTO | |Go to label |
|HEXM | |Hexadecimal mode |
|HMS+ | |Add x and y using H.MMSSss |
|HMS- | |Subtract x from y H.MMSSss |
|I+ | | |Inc. row pointer (matrix)
|I- | | |Dec. row pointer (matrix)
|INDEX | |Index matrix |
|INPUT | |User input (prog. only) |
|INSR | |Insert row (matrix edition) |
|INTEG | |Integrate |
|INVRT |Invert matrix in X-register | |
|IP | | |Return integer part
|ISG | |Increment, skip if greater |
|J+ | | |Inc. column pointer (matrix)
|J- | | |Dec. column pointer (matrix)
|KEYASN |Key-assignments mode | |
|KEYG | |On key, go to |
|KEYX | |On key, execute |
|LASTX |Last x | |
|LBL | |Label |
|LCLBL | |Local label mode |
|LINF | |Linear ﬁt model |
|LINE | |Linear mode (six sum regs) |
|LIST | |List program lines |
|LN | | |Natural logarithm
|LN1+X | |Nat log for values near zero |
|LOG | |Common logarithm |
|LOGF | |Logarithmic ﬁt |
|MAN | |Manual printing |
|MAT? | |Matrix test |
|MEAN | |Arithmetic mean (average) |
|MENU | |Programmable MENU |
|MOD | |Modulo |
|MVAR | |Menu variable |
|N! | | |Factorial
|NEWMAT |New matrix | |
|NORM | |Normal printing |
|NOT | |Logical NOT |
|OCTM | |Octal mode |
|OFF | |Off |
|OLD | |Old element value |
|ON | | |Continuous on
|OR | | |Logical OR
|PERM | |Permutations |
|PGMINT |Program to integrate | |
|PGMSLV |Program to solve | |
|PI | | |pi
|PIXEL | |Pixel on |
|POLAR |Polar mode | |
|POSA | |Position in alpha |
|PRA | |Print alpha |
|PRLCD |Print LCD | |
|PROFF |Printing off | |
|PROMPT |Prompt | |
|PRON | |Printing on |
|PR? | |Print program |
|PRSTK |Print stack | |
|PRUSR |Print user vars and labels | |
|PRV | |Print variable |
|PRX | |Print X-register |
|PR2 | |Print summation registers |
|PSE | |Pause |
|PUTM | |Put matrix |
|PWRF | |Power ﬁt |
|QUIET | |Quiet mode |
|RAD | |Radians mode |
|RAN | |Random number |
|RCL | |Recall |
|RCL+ | |Recall add |
|RCL- | |Recall subtract |
|RCL× | |Recall multiply |
|RCL÷ | |Recall divide |
|RCLEL |Recall element | |
|RCLIJ | |Recall IJ pointers |
|RDX, | |Radix comma |
|RDX. | |Radix period |
|REALRES |Real-results only | |
|REAL? | |Real test |
|RECT | |Rectangular mode |
|RND | |Round |
|RNRM | |Row norm |
|ROTXY |Rotate y by x bits | |
|RSUM | |Row sum |
|RTN | |Return |
|R<>R | |Row swap row |
|R↑ | | |Roll up
|R↓ | | |Roll down
|SCI | |Scientiﬁc notation |
|SDEV | |Standard deviation |
|SEED | |Seed (for RAN) |
|SF | | |Set ﬂag
|SIGN | |Sign |
|SIN | |Sine |
|SINH | |Hyperbolic sine |
|SIZE | |Size of REGS |
|SLOPE | |Slope |
|SOLVE | |Solve for variable |
|SQRT | |Square root |
|SST | |Single step |
|STO | |Store |
|STO+ | |Store add |
|STO- | |Store subtract |
|STO× | |Store multiply |
|STO÷ | |Store divide |
|STOEL |Store element | |
|STOIJ | |Store IJ pointers |
|STOP | |Stop program |
|STR? | |String test |
|SUM | |Recall Σx and Σy |
|TAN | |Tangent |
|TANH | |Hyperbolic tangent |
|TONE | |Tone (0-9) |
|TRACE |Trace printing | |
|TRANS |Transpose matrix | |
|UVEC | |Unit vector |
|VARMENU |Variable menu | |
|VIEW | |View |
|WMEAN |Weighted mean | |
|WRAP | |Wrap mode |
|X<> | |x exchange |
|X<>Y | |x exchange y |
|XEQ | |Execute |
|XOR | |Exclusive OR |
|XTOA | |X to alpha |
|X^2^ | | |Square, x^2^
|YINT | |Y-intercept |
|Y^X^ | | |Power, y^x^
|1/X | |Reciprocal |
|10^X^ | |Common exponential, 10x |
|+ | | |Add
|- | | |Subtract
|× | | |Multiply
|÷ | | |Divide
|+/- | |Change sign |
|Σ+ | | |Summation plus
|Σ- | | |Summation minus
|ΣREG | |Set loc. of 1. sum reg |
|ΣREG? | |Recall loc. of 1. sum reg |
|→DEC | |To decimal |
|→DEG | |To degrees |
|→HMS | |To hours-minutes-seconds |
|→HR | |To decimal hours |
|→OCT | |To octal |
|→POL | |To polar |
|→RAD | |To radians |
|→REC | |To rectangular |
|← | | |Index pointers left
|↑ | | |Index pointers up
|↓ | | |Index pointers down
|→ | | |Index pointers right
|% | | |Percent
|%CH | |Percent change |
|ADATE |Append date from X to alpha | |
|ATIME | |Append time from X to alpha |
|AT24 | |Append 24h time from X to a. |
|CL12 | |Set 12h time format AM/PM |
|CL24 | |Set 24h time format |
|DATE | |Put date to X register |
|DATE+ |Add dates in X and Y regs | |
|DDAYS |Delta days of X and Y regs | |
|DMY | |Set date format to DMY |
|DOW | |Day of Week of date in X reg |
|MDY | |Set date format to MDY |
|TIME | |Put time to X register |
|===

 +
 +
Note: If you execute an link:#HP-41_Functions[HP-41 Function], it is
automatically converted into the corresponding DM42 function. +
 +

[[Test_Functions]]
=== Test Functions

If true, execute the next program line. If false, skip the next program
line. +

[cols=",",]
|===
|X<0? |less than zero
|X<Y? |less than y
|X≤0? |less than or equal to zero
|X≤Y? |less than or equal to y
|X=0? |equal to zero
|X=Y? |equal to y
|X≠0? |not equal to zero
|X≠Y? |not equal to y
|X>0? |greater than zero
|X>Y? |greater than y
|X≥0? |greater than or equal to zero
|X≥Y? |greater than or equal to y
|===

 +
 +

[[HP-41_Functions]]
=== HP41 Functions

[cols=",,,",]
|===
|CHS | |+/- |
|DEG | |→DEG |
|D-R | |→RAD |
|ENTER↑ |ENTER | |
|FACT | |N! |
|FRC | |FP |
|HMS | |→HMS |
|HR | | |→HR
|INT | |IP |
|OCT | |→OCT |
|P-R | |→REC |
|RDN | |R↓ |
|R-D | |→DEG |
|R-P | |→POL |
|ST+ | |STO+ |
|ST- | |STO- |
|ST* | |STO× |
|ST/ | |STO÷ |
|X<=0? | |X≤0? |
|X<=Y? | |X≤Y? |
|* | | |×
|/ | | |÷
|===

 +

[[Using_the_ALPHA_Menu]]
=== Using the ALPHA Menu

To type an alpha string into the alpha register:

. Press [.button]#ALPHA# to select the ALPHA menu.
. Optional: press [.button]#ENTER# to turn on the cursor (in
Program-entry mode, inserts the I- symbol).
. Type the string using the characters shown below. Use [.button]#shift#
to type lowercase letters.
. Press [.button]#EXIT# or [.button]#ENTER#

 +
 +

[[Flags]]
=== Flags

* 00-10 User Flags
* 11 Auto Execute
* 12 Print Double-wide
* 13 Print Lowercase
* 15-16 Print Mode
* 19-20 General Use
* 21 Printer Enable
* 22 Numeric Input
* 23 Alpha Input
* 24 Ignore Range Errors
* 25 Ignore Next Error
* 26 Beeper Enable
* 27 CUSTOM Menu
* 28 Radix Mark Period
* 29 Digit Separators
* 30 Stack Lift Disable
* 31 DMY Date Format
* 34-35 AGRAPH Control
* 36-39 Number of Digits
* 40-41 Display Format
* 42 Grads Mode
* 43 Radians Mode
* 44 Continuous On
* 45 Solving
* 46 Integrating
* 47 Variable Menu
* 48 Alpha Mode
* 49 Low Battery Power
* 50 Message
* 51 Two-Line Message
* 52 Program-Entry Mode
* 53 INPUT
* 55 Printer Existence
* 56 Linear Model
* 57 Logarithmic Model
* 58 Exponential Model
* 59 Power Model
* 60 AllΣ Mode
* 61 Log Model Invalid
* 62 Exp Model Invalid
* 63 Pwr Model Invalid
* 64 Shift State
* 65 Matrix Editor In Use
* 66 Grow Mode
* 67 YMD Date Format
* 68-71 Base Mode
* 72 Local-Label Mode
* 73 Polar Mode
* 74 Real-Result Only
* 75 MENU
* 76 Edge Wrap
* 77 End Wrap
* 78 Base Signed
* 79 Base Wrap
* 81-99 User Flags

*Flags 0-10* are indicated by annunciators at the top of the display. +
*Flags 36-80* are read-only and cannot be altered with SF, CF, FS?C, or
FC?C. +
 +

[[Virtual_variables]]
=== Virtual variables

The concept of "Virtual Variables" is used to manage some of the new
features specific to the DM42 calculator. These are variables that do
not (and cannot, for that matter) exist in the DM42's variable table,
but are used to read or change state variables specific to DM42. +

[width="100%",cols="50%,50%",]
|===
|*DevID* |(read-only) Hardware device ID
|*GrMod* a|
(read-write) Graphic Modes

* 0 = HP-42S resolution 131x16
* 1 = reserved for future use
* 2 = DM42 half resolution 200x120
* 3 = DM42 full resolution 400x240

|*ResX* |(read-only) X-resolution for current graphics mode set in GrMod
|*ResY* |(read-only) Y-resolution for current graphics mode set in GrMod
|*Vbat* |(read-only) battery voltage
|===

 +
 +

[[F_Buttons]]
=== F-Buttons

The top row consists of six unprinted buttons referenced as F-Buttons
(F1-F6) or soft-menu buttons.

* *F1* Displays this Help
* *F2* Toggle the system soft menu visibility
* *F3* (not assigned)
* *F4* Increase buzzer volume
* *Shift-F4* Decrease buzzer volume
* *F5* Toggle stack alignment (Left, Right, Right Underlined)
* *Shift-F5* Toggle between sans and HP font
* *F6* Increase font size
* *Shift-F6* Decrease font size

 +
Note that font changes using F5/F6 affect displaying of calculator stack
and font in program mode and are stored independently for both stack and
program mode. +
 +

[[Screenshot]]
=== Screenshot

Pressing [.button]#SHIFT# and [.button]#DISP# simultaneously makes a
screenshot and saves a BMP graphics file in the folder /SCREENS. +
The file name is made up by the current date and time. +
 +

[[Setup_Menu]]
=== Setup Menu

* link:#File[File]
* link:#Calculator_State[Calculator State]
* link:#Print_To_File[Print_To_File]
* link:#Settings[Settings]
* link:#System[System]
* link:#About[About]

 +
 +

[[File]]
==== Setup Menu → File

Save and Load DM42 Programs to FAT Disk as *.raw files.

* Load Program +
Select RAW file and load in DM42 memory
* Save Program +
Select one or more DM42 programs from memory and save as one RAW file
* Activate USB Disk +
Prepare DM42 for connection with computer for file exchange
* Show Disk Info +
Display FAT Disk information

 +

[[Calculator_State]]
==== Setup Menu → Calculator State

The complete calculator state can be saved and loaded as one file
(*.f42).

* Load State +
Load previously saved calculator state
* Save State +
Save current calculator state as a file
* Load Clean State +
Load default settings

 +

[[Print_To_File]]
==== Setup Menu → Print To File

* Graphics Print +
Selecting this menu item enables printing to graphics file.
* Text Print +
Selecting this menu item enables printing to text file.
* Graphics in Text +
Selecting this menu item enables to see graphics in text file.
* Don't print to IR +
Selecting this menu item disables default printing to IR printer.

[[Settings]]
==== Setup Menu → Settings

* Set Time +
Set time and select 12h/24h format
* Set Date +
Set date and select MDY/DMY format
* Status Bar +
Display *State Filename* +
Display *Day of Week* +
Display *Date* +
Select a *Date Separator* of . - / +
Display *Month Shortcut* as 3 letter abrv. +
Display *Time* +
Display *Power Voltage in Header*
* Stack Font Sizes +
Allows to set font size ofsets for registers X, Y, Z, T, L and A
* Beep Mute +
Mute beep in all cases.
* Slow Auto-repeat +
This option makes auto-repeat of pressed and holded buttons slower.
* Stack Layout +
These are the options: +
XYZTL +
XYZTA +
XYZL +
XYZA +
XY +
LXYZT
* Dynamic Stack Extension +
This option enables or disables the 'Big Stack' extension of Free42

 +

[[System]]
==== Setup Menu → System

Warning: Certain actions in this menu can *destroy all stored data* of
the calculator. +
Please run 'Save Calculator State' in 'File' menu first to preserve data
over potential RESET. +

* Flashing firmware from FAT +
Starts flashing of new firmware if firmware file is copied to root of
FAT filesystem.
* Bootloader +
Connect USB to enter bootloader mode. Note that reset is the only way to
exit bootloader mode.
* Program Info +
Displays info about currently loaded program
* Reset to DMCP menu +
Resets calculator and enters DMCP menu
* Format FAT Disk +
This will format FAT filesystem. All data will be erased!
* FAT Disk Media Test +
All data stored in the FAT disk will be destroyed by this low-level
media test!
* Power OFF mode +
Allows to set power OFF mode. Only for diagnostics.
* Self Test +
Set of tests for KBD, LCD, IR, BEEP and Diagnostics

 +
 +

[[About]]
==== About

* *DM Calculator Platform* +
(C) 2014-2021, SwissMicros GmbH
* *Free42* +
(C) 2004-2021, Thomas Okken
* *Intel Decimal Floating-Point Lib* +
(C) 2007-2018, Intel Corp.
* *DM42 Quick Reference Guide* +
based on HP-42S Quick Reference Guide (c) Copyright 1988 Dex Smith

 +
link:#Top[Top]
